/*
 *
 *  * Copyright 2016 the original author or authors.
 *  *
 *  * Licensed under the Apache License, Version 2.0 (the "License");
 *  * you may not use this file except in compliance with the License.
 *  * You may obtain a copy of the License at
 *  *
 *  *      http://www.apache.org/licenses/LICENSE-2.0
 *  *
 *  * Unless required by applicable law or agreed to in writing, software
 *  * distributed under the License is distributed on an "AS IS" BASIS,
 *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  * See the License for the specific language governing permissions and
 *  * limitations under the License.
 *
 */

package leap.lang.jdbc;

import java.sql.*;

public abstract class ConnectionProxy extends ConnectionWrapper {

    protected boolean statementStackTrace;

    public ConnectionProxy(Connection conn) {
        super(conn);
    }

    public final Connection wrapped() {
        return conn;
    }

    @Override
    public final DatabaseMetaData getMetaData() throws SQLException {
        return proxyOfMetadata(conn.getMetaData());
    }

    @Override
    public final Statement createStatement() throws SQLException {
        return proxyOfStatement(conn.createStatement());
    }

    @Override
    public final Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
        return proxyOfStatement(conn.createStatement(resultSetType, resultSetConcurrency));
    }

    @Override
    public final Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        return proxyOfStatement(conn.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability));
    }

    @Override
    public final PreparedStatement prepareStatement(String sql) throws SQLException {
        return proxyOfPreparedStatement(conn.prepareStatement(sql), sql);
    }

    @Override
    public final PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
        return proxyOfPreparedStatement(conn.prepareStatement(sql, autoGeneratedKeys), sql);
    }

    @Override
    public final PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
        return proxyOfPreparedStatement(conn.prepareStatement(sql, columnIndexes), sql);
    }

    @Override
    public final PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
        return proxyOfPreparedStatement(conn.prepareStatement(sql, columnNames), sql);
    }

    @Override
    public final PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        return proxyOfPreparedStatement(conn.prepareStatement(sql, resultSetType, resultSetConcurrency), sql);
    }

    @Override
    public final PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        return proxyOfPreparedStatement(conn.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability), sql);
    }

    @Override
    public final CallableStatement prepareCall(String sql) throws SQLException {
        return proxyOfCallableStatement(conn.prepareCall(sql), sql);
    }

    @Override
    public final CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        return proxyOfCallableStatement(conn.prepareCall(sql, resultSetType, resultSetConcurrency), sql);
    }

    @Override
    public final CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        return proxyOfCallableStatement(conn.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability), sql);
    }

    /**
     * Test the type of the statement and return the proxy of it.
     */
    protected Statement proxyOf(Statement stmt) {
        if (stmt instanceof PreparedStatement) {
            return proxyOfPreparedStatement((PreparedStatement) stmt, null);
        }

        if (stmt instanceof CallableStatement) {
            return proxyOfCallableStatement((CallableStatement) stmt, null);
        }

        return proxyOfStatement(stmt);
    }

    /**
     * Returns the proxy of {@link DatabaseMetaData}.
     */
    protected DatabaseMetadataProxy proxyOfMetadata(DatabaseMetaData md) {
        return new DatabaseMetadataProxy(this, md);
    }

    /**
     * Returns the proxy of {@link Statement}.
     */
    protected StatementProxy proxyOfStatement(Statement stmt) {
        return new StatementProxy(this, stmt, statementStackTrace);
    }

    /**
     * Returns the proxy of {@link PreparedStatement}.
     */
    protected PreparedStatementProxy proxyOfPreparedStatement(PreparedStatement ps, String sql) {
        return new PreparedStatementProxy(this, ps, sql, statementStackTrace);
    }

    /**
     * Returns the proxy of {@link CallableStatement}.
     */
    protected CallableStatementProxy proxyOfCallableStatement(CallableStatement cs, String sql) {
        return new CallableStatementProxy<>(this, cs, sql, statementStackTrace);
    }

    /**
     * Close the statement.
     */
    protected void closeStatement(StatementProxy stmt) throws SQLException {
        stmt.wrapped().close();
    }

    protected static StackTraceElement[] getStackTrace(Exception e) {
        return e.getStackTrace();
    }

}